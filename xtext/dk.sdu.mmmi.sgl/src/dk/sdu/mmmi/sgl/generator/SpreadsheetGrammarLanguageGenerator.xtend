/*
 * generated by Xtext
 */
package dk.sdu.mmmi.sgl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Grammar
import java.util.List
import java.util.ArrayList
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Block
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Rule
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Column
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.ColumnDefinition
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.RowSpec
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.ColumnSpec
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.BlockSpec

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class SpreadsheetGrammarLanguageGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		resource.allContents.filter(typeof(Grammar)).forEach[compile(fsa)]
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	}
	
	def compile(Grammar grammar, IFileSystemAccess fsa) {
		fsa.generateFile("generated/Parser_"+grammar.name+".py", grammar.generate)
	}
	
	def generate(Grammar grammar) '''
	import cellparser
	class Parse«grammar.name»(object):
		def __init__(self, spreadsheet):
			self.spreadsheet = spreadsheet
		def matchColumns(self,columnHeaders):
			return columnHeaders==[«FOR h:grammar.computeHeaders SEPARATOR ","»"«h»"«ENDFOR»]
		def parseBlock(self,columnHeaders,row,column,height):
			results = []
			relativeRow = 0
			while relativeRow<height:
				increment_and_object = self.parseObject(row+relativeRow,column,columnHeaders)
				results.append(increment_and_object[1])
				relativeRow += increment_and_object[0]
			return results
	'''
	
	//
	// Computation of headers
	//
	
	def List<String> computeHeaders(Grammar grammar) {
		val result = new ArrayList<String>()
		grammar.root.collectHeaders(result)
		result
	}
	
	def dispatch void collectHeaders(Block block, List<String> collector) {
		block.columns.forEach[collectHeaders(collector)]
	}
	
	def dispatch void collectHeaders(Rule rule, List<String> collector) { }
	
	def dispatch void collectHeaders(Column column, List<String> collector) {
		column.def.collectHeaders(collector)
	}
	
	def dispatch void collectHeaders(ColumnDefinition cdef, List<String> collector) {
		cdef.spec.collectHeaders(collector)
	}

	def dispatch void collectHeaders(RowSpec spec, List<String> collector) {
		collector.add(spec.header)
	}

	def dispatch void collectHeaders(BlockSpec spec, List<String> collector) {
		spec.kind.collectHeaders(collector)
	}

}
