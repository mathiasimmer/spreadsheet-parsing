/**
 * generated by Xtext
 */
package dk.sdu.mmmi.sgl.generator;

import com.google.common.collect.Iterators;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Block;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.BlockSpec;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Column;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.ColumnDefinition;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.ColumnSpec;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Grammar;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.RowSpec;
import dk.sdu.mmmi.sgl.spreadsheetGrammarLanguage.Rule;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
@SuppressWarnings("all")
public class SpreadsheetGrammarLanguageGenerator implements IGenerator {
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterator<Grammar> _filter = Iterators.<Grammar>filter(_allContents, Grammar.class);
    final Procedure1<Grammar> _function = new Procedure1<Grammar>() {
      public void apply(final Grammar it) {
        SpreadsheetGrammarLanguageGenerator.this.compile(it, fsa);
      }
    };
    IteratorExtensions.<Grammar>forEach(_filter, _function);
  }
  
  public void compile(final Grammar grammar, final IFileSystemAccess fsa) {
    String _name = grammar.getName();
    String _plus = ("generated/Parser_" + _name);
    String _plus_1 = (_plus + ".py");
    CharSequence _generate = this.generate(grammar);
    fsa.generateFile(_plus_1, _generate);
  }
  
  public CharSequence generate(final Grammar grammar) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import cellparser");
    _builder.newLine();
    _builder.append("class Parse");
    String _name = grammar.getName();
    _builder.append(_name, "");
    _builder.append("(object):");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("def __init__(self, spreadsheet):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("self.spreadsheet = spreadsheet");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def getCell(self,row,column):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return self.spreadsheet.objCells.[row][column].data");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def matchColumns(self,columnHeaders):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return columnHeaders==[");
    {
      List<String> _computeHeaders = this.computeHeaders(grammar);
      boolean _hasElements = false;
      for(final String h : _computeHeaders) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "\t\t");
        }
        _builder.append("\"");
        _builder.append(h, "\t\t");
        _builder.append("\"");
      }
    }
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("def parseBlock(self,columnHeaders,row,column,height):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("results = []");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("relativeRow = 0");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("while relativeRow<height:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("increment_and_object = self.parseObject(row+relativeRow,column,columnHeaders)");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("results.append(increment_and_object[1])");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("relativeRow += increment_and_object[0]");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("return results");
    _builder.newLine();
    return _builder;
  }
  
  public List<String> computeHeaders(final Grammar grammar) {
    ArrayList<String> _xblockexpression = null;
    {
      final ArrayList<String> result = new ArrayList<String>();
      Block _root = grammar.getRoot();
      this.collectHeaders(_root, result);
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  protected void _collectHeaders(final Block block, final List<String> collector) {
    EList<Column> _columns = block.getColumns();
    final Consumer<Column> _function = new Consumer<Column>() {
      public void accept(final Column it) {
        SpreadsheetGrammarLanguageGenerator.this.collectHeaders(it, collector);
      }
    };
    _columns.forEach(_function);
  }
  
  protected void _collectHeaders(final Rule rule, final List<String> collector) {
  }
  
  protected void _collectHeaders(final Column column, final List<String> collector) {
    ColumnDefinition _def = column.getDef();
    this.collectHeaders(_def, collector);
  }
  
  protected void _collectHeaders(final ColumnDefinition cdef, final List<String> collector) {
    ColumnSpec _spec = cdef.getSpec();
    this.collectHeaders(_spec, collector);
  }
  
  protected void _collectHeaders(final RowSpec spec, final List<String> collector) {
    String _header = spec.getHeader();
    collector.add(_header);
  }
  
  protected void _collectHeaders(final BlockSpec spec, final List<String> collector) {
    Block _kind = spec.getKind();
    this.collectHeaders(_kind, collector);
  }
  
  public void collectHeaders(final EObject block, final List<String> collector) {
    if (block instanceof Block) {
      _collectHeaders((Block)block, collector);
      return;
    } else if (block instanceof BlockSpec) {
      _collectHeaders((BlockSpec)block, collector);
      return;
    } else if (block instanceof RowSpec) {
      _collectHeaders((RowSpec)block, collector);
      return;
    } else if (block instanceof Rule) {
      _collectHeaders((Rule)block, collector);
      return;
    } else if (block instanceof Column) {
      _collectHeaders((Column)block, collector);
      return;
    } else if (block instanceof ColumnDefinition) {
      _collectHeaders((ColumnDefinition)block, collector);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(block, collector).toString());
    }
  }
}
